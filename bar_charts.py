# -*- coding: utf-8 -*-
"""Bar_Charts.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zs7gfyHAb5qlwH9nuzGGmPdsXJzFvv1w

#Imports
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
import statistics
from plotly.subplots import make_subplots
from scipy.stats import skew
from scipy.stats import kurtosis
import warnings
warnings.filterwarnings('ignore')

"""#Data"""

df = pd.read_json('/content/bitcoin_binance_trade_11.json')
df = df.iloc[:int(0.96*len(df))]
df

import pandas as pd
import time
s = time.time()
df = pd.read_csv("/content/test.csv")
e = time.time()
print("Pandas Loading Time = {}".format(e-s))

import modin.pandas as pdd
s = time.time()
df = pdd.read_csv("/content/test.csv")
e = time.time()
print("Modin Loading Time = {}".format(e-s))

px.line(df.iloc[int(0.8*len(df)):],x = 'time', y = 'price')

df_ = df.iloc[:int(0.24*len(df)),:]
df_

"""#Candle And Its Features - Code"""

class candle:

  def candle_and_features(self, memory, imbalanced_or_runs = False, theta_T = None):

    high = np.max(memory['price'])
    low =  np.min(memory['price'])
    close = memory['price'].values[-1]
    open = memory['price'].values[0]
    volume = np.sum(memory['qty'])
    time = memory['time'].values[0]
    mean_price = np.mean(memory['price'])
    mean_volume = np.mean(memory['qty'])
    #mod_price = statistics.mode(memory['price'])[0]
    #mod_volume = statistics.mode(memory['qty'])[0]
    median_price = statistics.median(memory['price'])
    median_volume = statistics.median(memory['qty'])
    std_price = np.std(memory['price'])
    std_volume = np.std(memory['qty'])
    upper_band_price = mean_price + 2*std_price
    lower_band_price = mean_price - 2*std_price
    upper_band_volume = mean_volume + 2*std_volume
    lower_band_volume = mean_volume - 2*std_volume
    skewness_price = skew(memory['price'], bias=False)
    kurtos_price = kurtosis(memory['price'], bias=False)
    skewness_volume = skew(memory['qty'], bias=False)
    kurtos_volume = kurtosis(memory['qty'], bias=False)
    vwap = np.average(memory['price'], weights=memory['qty'])
    no_ticks = len(memory)

    if imbalanced_or_runs:

      theta_is_positive = 1 if theta_T>=0 else 0
      close_gre_open = 1 if close>=open else 0
      new_row = np.array([time,open,high,low,close,volume,vwap,
                                mean_price,#mod_price,
                                median_price,std_price,skewness_price,kurtos_price,lower_band_price,upper_band_price,
                                mean_volume,#mod_volume,
                                median_volume,std_volume,skewness_volume,kurtos_volume,lower_band_volume,upper_band_volume,no_ticks,theta_is_positive,close_gre_open])
      cols = ['time','open','high','low','close','volume','vwap',
                            'mean_price',#'mod_price',
                            'median_price','std_price','skewness_price','kurtos_price','lower_band_price','upper_band_price',
                            'mean_volume',#'mod_volume',
                            'median_volume','std_volume','skewness_volume','kurtos_volume','lower_band_volume','upper_band_volume',
                            '#ticks','theta_is_positive?','candle_is_green?'
                            ]
    else:

      new_row = np.array([time,open,high,low,close,volume,vwap,
                                  mean_price,#mod_price,
                                  median_price,std_price,skewness_price,kurtos_price,lower_band_price,upper_band_price,
                                  mean_volume,#mod_volume,
                                  median_volume,std_volume,skewness_volume,kurtos_volume,lower_band_volume,upper_band_volume,no_ticks])
      cols = ['time','open','high','low','close','volume','vwap',
                                  'mean_price',#'mod_price',
                                  'median_price','std_price','skewness_price','kurtos_price','lower_band_price','upper_band_price',
                                  'mean_volume',#'mod_volume',
                                  'median_volume','std_volume','skewness_volume','kurtos_volume','lower_band_volume','upper_band_volume','#ticks'
                                  ]
    
    return (new_row, cols)

"""#Time Bars - Code"""

class time_bars(candle):

  def __init__(self, df):

    self.df = df
    self.df_time_bar = pd.DataFrame(None)

  def time_bar_chart(self,timestamp='5m'):

    self.df_time_bar = self.df.resample(timestamp).agg({'price': 'ohlc', 'qty': 'sum'})

    return self.df_time_bar

"""#Balanced Charts - Code"""

class balanced_charts(candle):

  def __init__(self, df):

    self.df = df
    self.df_tick = pd.DataFrame(None)
    self.df_volume = pd.DataFrame(None)
    self.df_dollar = pd.DataFrame(None)


  def tick_bar(self, number_of_tick_data):

    self.number_of_tick_data = number_of_tick_data

    number_of_candles = int(len(self.df)/self.number_of_tick_data) + 1

    for i in range(number_of_candles):

      if i==number_of_candles-1:

        candle = self.df.iloc[i*self.number_of_tick_data:,:]
      else:

        candle = self.df.iloc[i*self.number_of_tick_data:(i+1)*self.number_of_tick_data,:]
      values, columns = self.candle_and_features(candle)
      self.df_tick = self.df_tick.append([values])

    self.df_tick.index = np.array(range(len(self.df_tick)))
    self.df_tick.columns = columns

    self.df_tick[self.df_tick.columns[1:]] = self.df_tick[self.df_tick.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_tick)):

      self.df_tick['time'][u] = pd.to_datetime(self.df_tick['time'][u].replace('T',' ').replace('Z','').split('.')[0])

    return self.df_tick

  def volume_bar(self, threshold_for_volume):

    sum = 0
    j = 0
    k = 0

    while j<len(self.df):

      sum += self.df['qty'][j]
      memory = self.df.iloc[k:j+1,:]

      if sum >= threshold_for_volume:


        values, columns = self.candle_and_features(memory)
        self.df_volume = self.df_volume.append([values])

        k = j + 1
        sum = 0
      
      j += 1

    self.df_volume.index = np.array(range(len(self.df_volume)))
    self.df_volume.columns = columns

    self.df_volume[self.df_volume.columns[1:]] = self.df_volume[self.df_volume.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_volume)):

      self.df_volume['time'][u] = pd.to_datetime(self.df_volume['time'][u].replace('T',' ').replace('Z','').split('.')[0])

    return self.df_volume

  def dollar_bar(self, threshold_for_dollar):

    sum = 0
    j = 0
    k = 0

    while j<len(self.df):

      sum += self.df['qty'][j] * self.df['price'][j]
      memory = self.df.iloc[k:j+1,:]
      if sum >= threshold_for_dollar:
        values, columns = self.candle_and_features(memory)
        self.df_dollar = self.df_dollar.append([values])

        k = j + 1
        sum = 0
      
      j += 1

    self.df_dollar.index = np.array(range(len(self.df_dollar)))
    self.df_dollar.columns = columns

    self.df_dollar[self.df_dollar.columns[1:]] = self.df_dollar[self.df_dollar.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_dollar)):

      self.df_dollar['time'][u] = pd.to_datetime(self.df_dollar['time'][u].replace('T',' ').replace('Z','').split('.')[0])

    return self.df_dollar

"""#Imbalanced Charts - Code"""

class imbalanced_charts(candle):

  def __init__(self, df):

    self.df = df
    self.df_tick = pd.DataFrame(None)
    self.df_volume = pd.DataFrame(None)
    self.df_dollar = pd.DataFrame(None)


  def ema(self, s, n):

    s = np.array(s)
    ema = []
    j = 1

    #get n sma first and calculate the next n period ema
    sma = sum(s[:n]) / n
    multiplier = 0.9
    ema.append(sma)

    #EMA(current) = ( (Price(current) - EMA(prev) ) x Multiplier) + EMA(prev)
    ema.append(( (s[n] - sma) * multiplier) + sma)

    #now calculate the rest of the values
    for i in s[n+1:]:
        tmp = ( (i - ema[j]) * multiplier) + ema[j]
        j = j + 1
        ema.append(tmp)

    return ema[-1]



  def tick_bar(self, initial_value = 5000):
    
    theta_T = 0
    j, o = initial_value, initial_value
    b_previous = 1
    counter = 0
    last_tick = False
    candles_with_label_one = 0
    ticks = [j]
    initial_prob = []
    E_0_T = j

    for i in range(1,j):

      change = self.df['price'][self.df.index[i]] - self.df['price'][self.df.index[i-1]] 

      if change > 0:

        initial_prob.append(1.0)
        b_previous = 1
        
      elif change < 0:

        initial_prob.append(0.0)

        b_previous = -1

      else:

        if b_previous == 1.0:
          initial_prob.append(1.0)
        else:
          initial_prob.append(0.0)

    
    prob_1 = sum(initial_prob)/j
    probs = [prob_1]


    while j < len(self.df):

      counter += 1

      if j == len(self.df) - 1:

        last_tick = True

      memory = self.df.iloc[o:j+1,:]

      change = self.df['price'][self.df.index[j]] - self.df['price'][self.df.index[j-1]] 
      
      if change > 0:

        candles_with_label_one += 1
        b_t, b_previous = 1,1
        
      elif change < 0:

        b_t, b_previous = -1,-1

      else:

        b_t = b_previous

        if b_t > 0:
          candles_with_label_one += 1

      theta_T += b_t

      dif = 2*prob_1 - 1
        
      E_0_theta_T = E_0_T * dif

      if abs(theta_T) > abs(E_0_theta_T) or last_tick:

        ticks.append(len(memory))
        E_0_T = self.ema(ticks, len(ticks)-1)
        ratio = candles_with_label_one/counter
        probs.append(ratio)
        prob_1 = self.ema(probs, len(probs)-1)
        values, columns = self.candle_and_features(memory, True, theta_T)
        self.df_tick = self.df_tick.append([values])

        o = j + 1
        counter, candles_with_label_one, theta_T = 0, 0, 0


        if last_tick:

          break

      j += 1

    self.df_tick.index = np.array(range(len(self.df_tick)))
    self.df_tick.columns = columns

    self.df_tick[self.df_tick.columns[1:]] = self.df_tick[self.df_tick.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_tick)):

      self.df_tick['time'][u] = pd.to_datetime(self.df_tick['time'][u].replace('T',' ').replace('Z','').split('.')[0])
    

    return self.df_tick


  def volume_bar(self, initial_values = 10000):
    
    theta_T = 0
    j, o = initial_value, initial_value
    b_previous = 1
    counter = 0
    last_tick = False
    candles_with_label_one, candles_with_label_none = 0, 0
    ticks = [j]
    initial_prob = []
    E_0_T = j
    V_B_1_hist, sum_v_b_1 = [], 0
    V_B_NEG_1_hist, sum_v_b_negative_1 = [], 0
    v_c_c_1, v_c_c_negative_1 = 0, 0
    c_aux_1 = 0
    c_aux_negative_1 = 0

    for i in range(1,j):

      change = self.df['price'][self.df.index[i]] - self.df['price'][self.df.index[i-1]] 

      if change > 0:
       
        sum_v_b_1 += self.df['qty'][self.df.index[i]]
        c_aux_1 += 1
        initial_prob.append(1.0)
        b_previous = 1
        
      elif change < 0:

        sum_v_b_negative_1 += self.df['qty'][self.df.index[i]]
        c_aux_negative_1 += 1 
        initial_prob.append(0.0)
        b_previous = -1

      else:

        if b_previous == 1.0:

          sum_v_b_1 += self.df['qty'][self.df.index[i]]
          c_aux_1 +=1 
          initial_prob.append(1.0)

        else:

          sum_v_b_negative_1 += self.df['qty'][self.df.index[i]]
          c_aux_negative_1 += 1 
          initial_prob.append(0.0)

    V_B_1_hist.append(sum_v_b_1/c_aux_1)
    V_B_NEG_1_hist.append(sum_v_b_negative_1/c_aux_negative_1)

    E_V_b_1 = sum_v_b_1 / c_aux_1
    E_V_b_negative_1 = sum_v_b_negative_1 / c_aux_negative_1

    prob_1 = sum(initial_prob)/j
    probs = [prob_1]

    while j < len(self.df):

      counter += 1

      if j == len(self.df) - 1:

        last_tick = True

      memory = self.df.iloc[o:j+1,:]

      change = self.df['price'][self.df.index[j]] - self.df['price'][self.df.index[j-1]] 
      v_t = self.df['qty'][self.df.index[j]]
      
      if change > 0:

        v_c_c_1 += v_t
        candles_with_label_one += 1
        b_t, b_previous = 1,1
        
      elif change < 0:

        v_c_c_negative_1 += v_t
        candles_with_label_none += 1
        b_t, b_previous = -1,-1

      else:

        b_t = b_previous

        if b_t > 0:
          v_c_c_1 += v_t
          candles_with_label_one += 1
        else:
          v_c_c_negative_1 += v_t
          candles_with_label_none += 1

      theta_T += b_t * v_t

      
        
      E_0_theta_T = E_0_T * (prob_1 * E_V_b_1 - (1-prob_1) * E_V_b_negative_1)
      

      if abs(theta_T) > abs(E_0_theta_T) or last_tick:

        ticks.append(len(memory))
        E_0_T = self.ema(ticks, len(ticks)-1)
        

        V_B_1_hist.append(v_c_c_1/(candles_with_label_one+1))
        V_B_NEG_1_hist.append(v_c_c_negative_1/(candles_with_label_none+1))

        E_V_b_1 = self.ema(V_B_1_hist, len(V_B_1_hist)-1)
        E_V_b_negative_1 = self.ema(V_B_NEG_1_hist, len(V_B_NEG_1_hist)-1)

        ratio = candles_with_label_one/counter
        probs.append(ratio)
        prob_1 = self.ema(probs, len(probs)-1)
        values, columns = self.candle_and_features(memory, True, theta_T)
        self.df_volume = self.df_volume.append([values])

        o = j + 1
        counter, candles_with_label_one, theta_T, v_c_c_1, v_c_c_negative_1 ,candles_with_label_none = 0, 0, 0, 0, 0, 0


        if last_tick:

          break

      j += 1

    self.df_volume.index = np.array(range(len(self.df_volume)))
    self.df_volume.columns = columns


    self.df_volume[self.df_volume.columns[1:]] = self.df_volume[self.df_volume.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_volume)):

      self.df_volume['time'][u] = pd.to_datetime(self.df_volume['time'][u].replace('T',' ').replace('Z','').split('.')[0])
    return self.df_volume


  def dollar_bar(self, initial_value = 10000):
    
    theta_T = 0
    j, o = initial_value, initial_value

    b_previous = 1
    counter = 0
    last_tick = False
    candles_with_label_one, candles_with_label_none = 0, 0
    ticks = [j]
    initial_prob = []
    E_0_T = j
    D_B_1_hist, sum_d_b_1 = [], 0
    D_B_negative_1_hist, sum_d_b_negative_1 = [], 0
    d_c_c_1, d_c_c_negative_1 = 0, 0
    c_aux_1 = 0
    c_aux_negative_1 = 0

    for i in range(1,j):

      change = self.df['price'][self.df.index[i]] - self.df['price'][self.df.index[i-1]] 

      if change > 0:
       
        sum_d_b_1 += self.df['qty'][self.df.index[i]] *  self.df['price'][self.df.index[i]] 
        c_aux_1 += 1
        initial_prob.append(1.0)
        b_previous = 1
        
      elif change < 0:

        sum_d_b_negative_1 += self.df['qty'][self.df.index[i]] * self.df['price'][self.df.index[i]]
        c_aux_negative_1 += 1 
        initial_prob.append(0.0)
        b_previous = -1

      else:

        if b_previous == 1.0:

          sum_d_b_1 += self.df['qty'][self.df.index[i]] *  self.df['price'][self.df.index[i]]
          c_aux_1 +=1 
          initial_prob.append(1.0)

        else:

          sum_d_b_negative_1 += self.df['qty'][self.df.index[i]] *  self.df['price'][self.df.index[i]]
          c_aux_negative_1 += 1 
          initial_prob.append(0.0)

    D_B_1_hist.append(sum_d_b_1/c_aux_1)
    D_B_negative_1_hist.append(sum_d_b_negative_1/c_aux_negative_1)

    E_D_b_1 = sum_d_b_1 / c_aux_1
    E_D_b_negative_1 = sum_d_b_negative_1 / c_aux_negative_1

    prob_1 = sum(initial_prob)/j
    probs = [prob_1]

    while j < len(self.df):

      counter += 1

      if j == len(self.df) - 1:

        last_tick = True

      memory = self.df.iloc[o:j+1,:]

      change = self.df['price'][self.df.index[j]] - self.df['price'][self.df.index[j-1]] 
      d_t = self.df['qty'][self.df.index[j]] * self.df['price'][self.df.index[j]]
      
      if change > 0:

        d_c_c_1 += d_t
        candles_with_label_one += 1
        b_t, b_previous = 1,1
        
      elif change < 0:

        d_c_c_negative_1 += d_t
        candles_with_label_none += 1
        b_t, b_previous = -1,-1

      else:

        b_t = b_previous

        if b_t > 0:
          d_c_c_1 += d_t
          candles_with_label_one += 1
        else:
          d_c_c_negative_1 += d_t
          candles_with_label_none += 1

      theta_T += b_t * d_t

      
        
      E_0_theta_T = E_0_T * (prob_1 * E_D_b_1 - (1-prob_1) * E_D_b_negative_1)
      

      if abs(theta_T) > abs(E_0_theta_T) or last_tick:

        ticks.append(len(memory))
        E_0_T = self.ema(ticks, len(ticks)-1)
        

        D_B_1_hist.append(d_c_c_1/(candles_with_label_one+1))
        D_B_negative_1_hist.append(d_c_c_negative_1/(candles_with_label_none+1))

        E_D_b_1 = self.ema(D_B_1_hist, len(D_B_1_hist)-1)
        E_D_b_negative_1 = self.ema(D_B_negative_1_hist, len(D_B_negative_1_hist)-1)

        ratio = candles_with_label_one/counter
        probs.append(ratio)
        prob_1 = self.ema(probs, len(probs)-1)
        values, columns = self.candle_and_features(memory, True, theta_T)
        self.df_dollar = self.df_dollar.append([values])

        o = j + 1
        counter, candles_with_label_one, theta_T, d_c_c_1, d_c_c_negative_1 ,candles_with_label_none = 0, 0, 0, 0, 0, 0


        if last_tick:

          break

      j += 1

    self.df_dollar.index = np.array(range(len(self.df_dollar)))
    self.df_dollar.columns = columns

    self.df_dollar[self.df_dollar.columns[1:]] = self.df_dollar[self.df_dollar.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_dollar)):

      self.df_dollar['time'][u] = pd.to_datetime(self.df_dollar['time'][u].replace('T',' ').replace('Z','').split('.')[0])

    return self.df_dollar

"""#Run Bars - Code"""

class runs_bars(candle):

  def __init__(self, df):

    self.df = df
    self.df_tick = pd.DataFrame(None)
    self.df_volume = pd.DataFrame(None)
    self.df_dollar = pd.DataFrame(None)

  def ema(self, s, n):

    s = np.array(s)
    ema = []
    j = 1

    #get n sma first and calculate the next n period ema
    sma = sum(s[:n]) / n
    multiplier = 0.9
    ema.append(sma)

    #EMA(current) = ( (Price(current) - EMA(prev) ) x Multiplier) + EMA(prev)
    ema.append(( (s[n] - sma) * multiplier) + sma)

    #now calculate the rest of the values
    for i in s[n+1:]:
        tmp = ( (i - ema[j]) * multiplier) + ema[j]
        j = j + 1
        ema.append(tmp)

    return ema[-1]

  def tick_bar(self, initial_value = 5000):
    
    theta_T = 0
    j, o = initial_value, initial_value
    b_previous = 1
    counter = 0
    last_tick = False
    candles_with_label_one, candles_with_label_none = 0, 0
    ticks = [j]
    initial_prob = []
    E_0_T = j

    for i in range(1,j):

      change = self.df['price'][self.df.index[i]] - self.df['price'][self.df.index[i-1]] 

      if change > 0:

        initial_prob.append(1.0)
        b_previous = 1
        
      elif change < 0:

        initial_prob.append(0.0)

        b_previous = -1

      else:

        if b_previous == 1.0:
          initial_prob.append(1.0)
        else:
          initial_prob.append(0.0)

    
    prob_1 = sum(initial_prob)/j
    probs = [prob_1]


    while j < len(self.df):

      counter += 1

      if j == len(self.df) - 1:

        last_tick = True

      memory = self.df.iloc[o:j+1,:]

      change = self.df['price'][self.df.index[j]] - self.df['price'][self.df.index[j-1]] 
      
      if change > 0:

        candles_with_label_one += 1
        b_t, b_previous = 1,1
        
      elif change < 0:

        candles_with_label_none +=1
        b_t, b_previous = -1,-1

      else:

        b_t = b_previous

        if b_t > 0:
          candles_with_label_one += 1
        else:
          candles_with_label_none +=1

      theta_T = max(candles_with_label_one, candles_with_label_none)

      dif = max(prob_1, 1-prob_1)
        
      E_0_theta_T = E_0_T * dif

      if abs(theta_T) > abs(E_0_theta_T) or last_tick:

        ticks.append(len(memory))
        E_0_T = self.ema(ticks, len(ticks)-1)
        ratio = candles_with_label_one/counter
        probs.append(ratio)
        prob_1 = self.ema(probs, len(probs)-1)
        values, columns = self.candle_and_features(memory, True, theta_T)
        self.df_tick = self.df_tick.append([values])

        o = j + 1
        counter, candles_with_label_one, candles_with_label_none, theta_T = 0, 0, 0, 0


        if last_tick:

          break

      j += 1

    self.df_tick.index = np.array(range(len(self.df_tick)))
    self.df_tick.columns = columns

    self.df_tick[self.df_tick.columns[1:]] = self.df_tick[self.df_tick.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_tick)):

      self.df_tick['time'][u] = pd.to_datetime(self.df_tick['time'][u].replace('T',' ').replace('Z','').split('.')[0])

    return self.df_tick

  def volume_bar(self, initial_value=10000):
    
    theta_T = 0
    j, o = initial_value, initial_value

    b_previous = 1
    counter = 0
    last_tick = False
    candles_with_label_one, candles_with_label_none = 0, 0
    ticks = [j]
    initial_prob = []
    E_0_T = j
    V_B_1_hist, sum_v_b_1 = [], 0
    V_B_NEG_1_hist, sum_v_b_negative_1 = [], 0
    v_c_c_1, v_c_c_negative_1 = 0, 0
    c_aux_1 = 0
    c_aux_negative_1 = 0

    for i in range(1,j):

      change = self.df['price'][self.df.index[i]] - self.df['price'][self.df.index[i-1]] 

      if change > 0:
       
        sum_v_b_1 += self.df['qty'][self.df.index[i]]
        c_aux_1 += 1
        initial_prob.append(1.0)
        b_previous = 1
        
      elif change < 0:

        sum_v_b_negative_1 += self.df['qty'][self.df.index[i]]
        c_aux_negative_1 += 1 
        initial_prob.append(0.0)
        b_previous = -1

      else:

        if b_previous == 1.0:

          sum_v_b_1 += self.df['qty'][self.df.index[i]]
          c_aux_1 +=1 
          initial_prob.append(1.0)

        else:

          sum_v_b_negative_1 += self.df['qty'][self.df.index[i]]
          c_aux_negative_1 += 1 
          initial_prob.append(0.0)

    V_B_1_hist.append(sum_v_b_1/c_aux_1)
    V_B_NEG_1_hist.append(sum_v_b_negative_1/c_aux_negative_1)

    E_V_b_1 = sum_v_b_1 / c_aux_1
    E_V_b_negative_1 = sum_v_b_negative_1 / c_aux_negative_1

    prob_1 = sum(initial_prob)/j
    probs = [prob_1]

    while j < len(self.df):

      counter += 1

      if j == len(self.df) - 1:

        last_tick = True

      memory = self.df.iloc[o:j+1,:]

      change = self.df['price'][self.df.index[j]] - self.df['price'][self.df.index[j-1]] 
      v_t = self.df['qty'][self.df.index[j]]
      
      if change > 0:

        v_c_c_1 += v_t
        candles_with_label_one += 1
        b_t, b_previous = 1,1
        
      elif change < 0:

        v_c_c_negative_1 += v_t
        candles_with_label_none += 1
        b_t, b_previous = -1,-1

      else:

        b_t = b_previous

        if b_t > 0:
          v_c_c_1 += v_t
          candles_with_label_one += 1
        else:
          v_c_c_negative_1 += v_t
          candles_with_label_none += 1

      theta_T = max(v_c_c_1, v_c_c_negative_1)

      
        
      E_0_theta_T = E_0_T * (max(prob_1 * E_V_b_1 , (1-prob_1) * E_V_b_negative_1))
      

      if abs(theta_T) > abs(E_0_theta_T) or last_tick:

        ticks.append(len(memory))
        E_0_T = self.ema(ticks, len(ticks)-1)
        

        V_B_1_hist.append(v_c_c_1/(candles_with_label_one+1))
        V_B_NEG_1_hist.append(v_c_c_negative_1/(candles_with_label_none+1))

        E_V_b_1 = self.ema(V_B_1_hist, len(V_B_1_hist)-1)
        E_V_b_negative_1 = self.ema(V_B_NEG_1_hist, len(V_B_NEG_1_hist)-1)

        ratio = candles_with_label_one/counter
        probs.append(ratio)
        prob_1 = self.ema(probs, len(probs)-1)
        values, columns = self.candle_and_features(memory, True, theta_T)
        self.df_volume = self.df_volume.append([values])

        o = j + 1
        counter, candles_with_label_one, theta_T, v_c_c_1, v_c_c_negative_1 ,candles_with_label_none = 0, 0, 0, 0, 0, 0


        if last_tick:

          break

      j += 1

    self.df_volume.index = np.array(range(len(self.df_volume)))
    self.df_volume.columns = columns


    self.df_volume[self.df_volume.columns[1:]] = self.df_volume[self.df_volume.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_volume)):

      self.df_volume['time'][u] = pd.to_datetime(self.df_volume['time'][u].replace('T',' ').replace('Z','').split('.')[0])
    return self.df_volume


  def dollar_bar(self,initial_value=10000):
    
    theta_T = 0
    j, o = initial_value, initial_value

    b_previous = 1
    counter = 0
    last_tick = False
    candles_with_label_one, candles_with_label_none = 0, 0
    ticks = [j]
    initial_prob = []
    E_0_T = j
    D_B_1_hist, sum_d_b_1 = [], 0
    D_B_negative_1_hist, sum_d_b_negative_1 = [], 0
    d_c_c_1, d_c_c_negative_1 = 0, 0
    c_aux_1 = 0
    c_aux_negative_1 = 0

    for i in range(1,j):

      change = self.df['price'][self.df.index[i]] - self.df['price'][self.df.index[i-1]] 

      if change > 0:
       
        sum_d_b_1 += self.df['qty'][self.df.index[i]] *  self.df['price'][self.df.index[i]] 
        c_aux_1 += 1
        initial_prob.append(1.0)
        b_previous = 1
        
      elif change < 0:

        sum_d_b_negative_1 += self.df['qty'][self.df.index[i]] * self.df['price'][self.df.index[i]]
        c_aux_negative_1 += 1 
        initial_prob.append(0.0)
        b_previous = -1

      else:

        if b_previous == 1.0:

          sum_d_b_1 += self.df['qty'][self.df.index[i]] *  self.df['price'][self.df.index[i]]
          c_aux_1 +=1 
          initial_prob.append(1.0)

        else:

          sum_d_b_negative_1 += self.df['qty'][self.df.index[i]] *  self.df['price'][self.df.index[i]]
          c_aux_negative_1 += 1 
          initial_prob.append(0.0)

    D_B_1_hist.append(sum_d_b_1/c_aux_1)
    D_B_negative_1_hist.append(sum_d_b_negative_1/c_aux_negative_1)

    E_D_b_1 = sum_d_b_1 / c_aux_1
    E_D_b_negative_1 = sum_d_b_negative_1 / c_aux_negative_1

    prob_1 = sum(initial_prob)/j
    probs = [prob_1]


    while j < len(self.df):

      counter += 1

      if j == len(self.df) - 1:

        last_tick = True

      memory = self.df.iloc[o:j+1,:]

      change = self.df['price'][self.df.index[j]] - self.df['price'][self.df.index[j-1]] 
      d_t = self.df['qty'][self.df.index[j]] * self.df['price'][self.df.index[j]]
      
      if change > 0:

        d_c_c_1 += d_t
        candles_with_label_one += 1
        b_t, b_previous = 1,1
        
      elif change < 0:

        d_c_c_negative_1 += d_t
        candles_with_label_none += 1
        b_t, b_previous = -1,-1

      else:

        b_t = b_previous

        if b_t > 0:
          d_c_c_1 += d_t
          candles_with_label_one += 1
        else:
          d_c_c_negative_1 += d_t
          candles_with_label_none += 1

      theta_T = max(d_c_c_1, d_c_c_negative_1)

      
        
      E_0_theta_T = E_0_T * (max(prob_1 * E_D_b_1 , (1-prob_1) * E_D_b_negative_1))
      

      if abs(theta_T) > abs(E_0_theta_T) or last_tick:

        ticks.append(len(memory))
        E_0_T = self.ema(ticks, len(ticks)-1)
        

        D_B_1_hist.append(d_c_c_1/(candles_with_label_one+1))
        D_B_negative_1_hist.append(d_c_c_negative_1/(candles_with_label_none+1))

        E_D_b_1 = self.ema(D_B_1_hist, len(D_B_1_hist)-1)
        E_D_b_negative_1 = self.ema(D_B_negative_1_hist, len(D_B_negative_1_hist)-1)

        ratio = candles_with_label_one/counter
        probs.append(ratio)
        prob_1 = self.ema(probs, len(probs)-1)
        values, columns = self.candle_and_features(memory, True, theta_T)
        self.df_dollar = self.df_dollar.append([values])

        o = j + 1
        counter, candles_with_label_one, theta_T, d_c_c_1, d_c_c_negative_1 ,candles_with_label_none = 0, 0, 0, 0, 0, 0


        if last_tick:

          break

      j += 1

    self.df_dollar.index = np.array(range(len(self.df_dollar)))
    self.df_dollar.columns = columns

    self.df_dollar[self.df_dollar.columns[1:]] = self.df_dollar[self.df_dollar.columns[1:]].apply(pd.to_numeric)
    for u in range(len(self.df_dollar)):

      self.df_dollar['time'][u] = pd.to_datetime(self.df_dollar['time'][u].replace('T',' ').replace('Z','').split('.')[0])

    return self.df_dollar

"""#Time Bars - Test"""

charts = time_bars(df_)
df_time_bar = charts.time_bar_chart('300s')
df_time_bar

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_time_bar['time'], close = df_time_bar['close'], high = df_time_bar['high'], low = df_time_bar['low'], open = df_time_bar['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_time_bar['time'],y=df_time_bar['close'],name='close')
f.add_scatter(x=df_time_bar['time'],y=df_time_bar['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_time_bar['time'],y=df_time_bar['lower_band_price'],name='lower_band_price')

f.show()

"""##Wanna Save?"""

path = 'determine the path here'
df_time_bar.to_csv(path = path)

"""#Balanced Charts - Test

##Tick
"""

tick_5_min = 6700
tick_15_min = 20000
tick_30_min = 40000
tick_1_h = 80000
tick_2_h = 160000
tick_4_h = 320000

charts = balanced_charts(df_)
df_tick_balanced = charts.tick_bar(tick_5_min)
df_tick_balanced

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_tick_balanced['time'], close = df_tick_balanced['close'], high = df_tick_balanced['high'], low = df_tick_balanced['low'], open = df_tick_balanced['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_tick_balanced['time'],y=df_tick_balanced['close'],name='close')
f.add_scatter(x=df_tick_balanced['time'],y=df_tick_balanced['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_tick_balanced['time'],y=df_tick_balanced['lower_band_price'],name='lower_band_price')

f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_tick_balanced.to_csv(path = path)

"""##Volume"""

volume_5_min = 250
volume_15_min = 750
volume_30_min = 1500
volume_1_h = 3000
volume_2_h = 5500
volume_4_h = 10000

charts = balanced_charts(df_)
df_volume_balanced = charts.volume_bar(volume_5_min)
df_volume_balanced

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_volume_balanced['time'], close = df_volume_balanced['close'], high = df_volume_balanced['high'], low = df_volume_balanced['low'], open = df_volume_balanced['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_volume_balanced['time'],y=df_volume_balanced['close'],name='close')
f.add_scatter(x=df_volume_balanced['time'],y=df_volume_balanced['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_volume_balanced['time'],y=df_volume_balanced['lower_band_price'],name='lower_band_price')

f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_volume_balanced.to_csv(path = path)

"""##Dollar"""

dollar_5_min = 14750000
dollar_15_min = 44250000
dollar_30_min = 88500000
dollar_1_h = 177000000
dollar_2_h = 320000000
dollar_4_h = 640000000

charts = balanced_charts(df_)
df_dollar_balanced = charts.dollar_bar(dollar_5_min)
df_dollar_balanced

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_dollar_balanced['time'], close = df_dollar_balanced['close'], high = df_dollar_balanced['high'], low = df_dollar_balanced['low'], open = df_dollar_balanced['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_dollar_balanced['time'],y=df_dollar_balanced['close'],name='close')
f.add_scatter(x=df_dollar_balanced['time'],y=df_dollar_balanced['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_dollar_balanced['time'],y=df_dollar_balanced['lower_band_price'],name='lower_band_price')

f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_dollar_balanced.to_csv(path = path)

"""#Imbalanced Charts - Test

##Tick
"""

charts = imbalanced_charts(df_)
df_tick_imbalanced = charts.tick_bar()
df_tick_imbalanced

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_tick_imbalanced['time'], close = df_tick_imbalanced['close'], high = df_tick_imbalanced['high'], low = df_tick_imbalanced['low'], open = df_tick_imbalanced['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_tick_imbalanced['time'],y=df_tick_imbalanced['close'],name='close')
f.add_scatter(x=df_tick_imbalanced['time'],y=df_tick_imbalanced['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_tick_imbalanced['time'],y=df_tick_imbalanced['lower_band_price'],name='lower_band_price')


f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_tick_imbalanced.to_csv(path = path)

"""##Volume"""

charts = imbalanced_charts(df_)
df_volume_imbalanced = charts.volume_bar()
df_volume_imbalanced

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_volume_imbalanced['time'], close = df_volume_imbalanced['close'], high = df_volume_imbalanced['high'], low = df_volume_imbalanced['low'], open = df_volume_imbalanced['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_volume_imbalanced['time'],y=df_volume_imbalanced['close'],name='close')
f.add_scatter(x=df_volume_imbalanced['time'],y=df_volume_imbalanced['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_volume_imbalanced['time'],y=df_volume_imbalanced['lower_band_price'],name='lower_band_price')

f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_volume_imbalanced.to_csv(path = path)

"""##Dollar"""

charts = imbalanced_charts(df_)
df_dollar_imbalanced = charts.dollar_bar()
df_dollar_imbalanced

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_dollar_imbalanced['time'], close = df_dollar_imbalanced['close'], high = df_dollar_imbalanced['high'], low = df_dollar_imbalanced['low'], open = df_dollar_imbalanced['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_dollar_imbalanced['time'],y=df_dollar_imbalanced['close'],name='close')
f.add_scatter(x=df_dollar_imbalanced['time'],y=df_dollar_imbalanced['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_dollar_imbalanced['time'],y=df_dollar_imbalanced['lower_band_price'],name='lower_band_price')


f.show()

(np.sum((df_dollar_imbalanced['close'] - df_volume_imbalanced['close'])**2)/len(df_dollar_imbalanced['close']))**0.5

"""###Wanna Save?"""

path = 'determine the path here'
df_dollar_imbalanced.to_csv(path = path)

"""#Runs Bars - Test

##Tick
"""

charts = runs_bars(df_)
df_tick_runs = charts.tick_bar()
df_tick_runs

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_tick_runs['time'], close = df_tick_runs['close'], high = df_tick_runs['high'], low = df_tick_runs['low'], open = df_tick_runs['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_tick_runs['time'],y=df_tick_runs['close'],name='close')
f.add_scatter(x=df_tick_runs['time'],y=df_tick_runs['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_tick_runs['time'],y=df_tick_runs['lower_band_price'],name='lower_band_price')


f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_tick_runs.to_csv(path = path)

"""##Volume"""

charts = runs_bars(df_)
df_volume_runs = charts.volume_bar()
df_volume_runs

fig = make_subplots(rows=1, cols=1)

fig.add_trace( go.Candlestick(x = df_volume_runs['time'], close = df_volume_runs['close'], high = df_volume_runs['high'], low = df_volume_runs['low'], open = df_volume_runs['open'],name='Candles') , row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_volume_runs['time'],y=df_volume_runs['close'],name='close')
f.add_scatter(x=df_volume_runs['time'],y=df_volume_runs['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_volume_runs['time'],y=df_volume_runs['lower_band_price'],name='lower_band_price')


f.show()

"""###Wanna Save?"""

path = 'determine the path here'
df_volume_runs.to_csv(path = path)

"""##Dollar"""

charts = runs_bars(df_)
df_dollar_runs = charts.dollar_bar()
df_dollar_runs

fig = make_subplots(rows=1, cols=1)

fig.add_trace(go.Candlestick(x = df_dollar_runs['time'], close = df_dollar_runs['close'], high = df_dollar_runs['high'], low = df_dollar_runs['low'], open = df_dollar_runs['open'],name='Candles'), row=1, col=1)
fig.show()

f = go.FigureWidget()
f.add_scatter(x=df_dollar_runs['time'],y=df_dollar_runs['close'],name='close')
f.add_scatter(x=df_dollar_runs['time'],y=df_dollar_runs['upper_band_price'],name='upper_band_price')
f.add_scatter(x=df_dollar_runs['time'],y=df_dollar_runs['lower_band_price'],name='lower_band_price')


f.show()

(np.sum((df_dollar_runs['close'] - df_volume_runs['close'])**2)/len(df_dollar_runs['close']))**0.5

"""###Wanna Save?"""

path = 'determine the path here'
df_dollar_runs.to_csv(path = path)